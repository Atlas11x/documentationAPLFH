Оффициальная документация по написанию программ на языке программирования APLFH

Синтаксис
Раздел первый: общие сведенья

APLFH основан на python.
Язык имеет динамическую типизацию, интерпретируемый

Имеет 4 типа данных:
bool(может принимать либо логическую единицу (true), либо лочический ноль (false))
int(целые числа),
float(числа с плавающей точкой), 
string(строки)

Операторы(числловые и логические) работают с данными типа int и float:
Имеют следующий вид:
(значение: int, bool) [Оператор] (значение: int, bool)

Возвращают число или логическое значение

+ сложение
- вычитание
* умножение
/ деление
> больше
< меньше
>= больше или равно
<= меньше или равно
== равно
!= не равно

Пример:
 ```py
 3 + 3
 ```
Пример2
 ```py
 3+3
 ```
Пример3
 ```true != false```

Логические операции:
Имеют следющий вид:
(значение) [операция] (значение)

and (и): возвращает true, если и первое, и второе значения равны true, иначе, возвращает false
or(или): возвращает true, если хотябы одно значение равно true, ииначе false
not(не): возвращает true, если значение false, иначе возвращает false (Работает как инвертор)

Пример
 ```
 not true
 ```
Пример2
 ```
 true and false
 ```

Раздел второй: переменные
Чтобы создать переменную, необходимо ввести код по следующему шаблону:
v (имя переменной) = (значение (может иметь любой из типов данных, которые поддерживаются ЯП))

Пример кода:
```py
 v test = true
 ```
Пример2
```py
 v var = "Hello"
 ```
 
В качестве значемния переменной, также может выступать другая переменная, или числовая операция
 
Пример3:
```py
v var1 = "Hello, "
v var2 = var1 + "world!"
#значение var2 - Hello, world!
```

Переменные могут передаваться всем операторам вместо чисел

Раздел третий:
Логическое ветвление

APLFH, как и большинство других функциональных языков программирования содержит логические конструкции. Главная из них - if
Имеет следующую конструкцию: 

if (условие) t {код, который исполнится, в случае, если условие верно}
или 
if (условие) t
    {код}
end

#Примечание: В случае, если вы пишете код в одну строку, то end ставить не нужно. Это распространяется и на другие конструкции, которые будут представлены ниже

Пример

```py
v a = 0
v d = false

if a == 0 t 
    v d = true
end
#d = true
```

Если вы хотите добавить код, который выполнится в случае, если условие не верно, то стоит добавить оператор else
if (условие) t {код}else {код, который выполнится, если условие не верно}

Пример:

```py
v a = 0
v t = false

if a == 1 t 
    v d = true
else
    v d = false
end
#d = false
```


Так же, можно добавлять условия между if и else, которые будут последовательно, проверяться, в случае, если условие первого if-a неверно.
Для этого необходимо использовать оператор elif.

Конструкция:
if(условие) t
(код)
elif(условие) t 
(код)
end
...
elif(условие) t
(код)
else 
(код)
end

Можно писать неограниченое кол-во elif - ов

Тоесть, данная конструкция работает следующим образом: если первый if не срабатывает, то срабатывает первый elif, если он также не срабатывает, то срабатывает следующий и т.д. пока код не дойдет до else. Если одно из условий выполнится, то другие (в т.ч else) условия этого блока (до оператора end) рассматриваться интерпретатором не будут. В данной конструкции else не обязателен (В случае, если не один из (el)if - ов не будет верен, то программа просто пропустит этот блок)



Раздел четвертый: повторение сегментов кода, циклы

Цикл for.

Если вы хотите повторить часть кода несколько раз, то потребуется цикл. APLFH есть 2 вида циклов.
Основной цикл - for.

Цикл имеет следующую конструкцию:
for i = {значение} to {значение} t
    {Повторяемый код}
end

Значение i будет увеличиваться каждую иттерацию цикла до тех пор, пока не дойдет до второго укаазанного значения.
Тоесть количество повторений в цикле будет равно Значение2 - Значение1. Это необходимо для определенных задач, в которых потребуется из цикла брать значение i.
К примеру следующий код считает от 0 до 10:

for i = 0 to 10 t i
^       ^    ^     ^
цикл нач.зн. кон.зн. вывод тек. значения  

При простом введении переменной выводится ее значение

Так же для лучшего понимания цикла for, стоит показать следующий пример:

v a = 1
for i = 1 to 10 t
    v a = a + 1
end
#a = 11

В данном примере каждую иттерацию цикла, значение переменной a = a + 1, то есть увеличивается на 1.

Цикл while:

Имеет следующую конструкцию:

while (Условие) t
    (Код)
end

Данный цикл работает просто: Пока условие верно - цикл работает, когда не верно - завершается, и интерпретатор продолжает Выполнять код после цикла.

Пример:
v a = 0
while a < 5 t
    v a = a + 1
end

#Пояснение
#Этот код можно расшифровать как:
#Создать переменную "а" и присвоить её значение 5.
#Пока а меньше 5
#а равняется а + 1 (Тоесть прибавить к а единицу)
#конец цикла

Раздел пятый: Функции и их создание

В нашем языке, как и в большинстве других, есть такое понятие, как функция. Функция - сегмент кода, который можно вызвать, и получить от него результат, отдав ему параметры.

Функции имеют слудующую конструкцию:

f [название функции]([аргумент 1, аргумент 2, ... аргумент n]) ->
    (код, который выполняет функция)
end

Для возврата значения необходимо использовать ключевое слово return

Пример:

f summ(x, y) -> #создаем функцию summ с двумя аргументами "x" и "y"
    return x + y #возвращаем сумму "x" и "y"
end

v test = summ(1, 2) #Вызываем функцию summ, задавая в качестве аргумента x 1, а в качестве аргумента y 2 и присваеваем значение, которое вернет функция переменной test.
#test = 3

Функция, также может не принимать никаких аргументов и (или) не возвращать ничего, к примеру просто меняя значение переменной:

v var = 0
#var = 0

f test() ->
    v var = 1
end

test()

#var = 1


Также, функции можно создавать и другим способом, помещая их в переменные 
#Понятия не имею нафига Purpled100 засунул 2 способа создания функций, когда на практике разницы нет. Иногда код с ними выглядит красивее или понятнее

Функции созданные таким образом мы называем анонимными:

v [название переменной] = f [название функции]([аргумент 1, аргумент 2...])
    (Исполняемый код)      #по факту название анонимной функции может быть любым, т.к. нигде не используется. Но для лучшей читаемости кода рекомендуем писать его со смыслом.
end

#Вызов анонимной функции:

[название созданной переменной]([аргументы])


Пример:
v t = 0
v summ = f func(x, y) -> #создаем функцию summ с двумя аргументами "x" и "y"
    return x + y #возвращаем сумму "x" и "y"
end

v t = summ(1, 2)

#t = 3



Раздел 6: встроенные функции.

Наш язык, как и большинство других, имеет встроеные функции. 

К примеру функция op(), которая не возвращает никаких значений, только берет аргумент и выводит его в консоль.

Пример: код для вывода надписи "Hello, world!" на экран:

op("Hello, world!")

или

v a = "Hello, world!"
op(a)

или

op("Hello, " + "world!")

и т.д.

Есть так же функции для того, что бы взять значение у пользователя (он должен ввести его в консоль): rd() для строк или rd_int() для чисел.

К примеру данная связка просто повторит введенное сообщение:

v data = rd()
op(data)

или короче:

op(rd())

Функция op() принимает аргументы, и просто выводит данные в консоль, не возвращая никакого значения, а rd() наоборот не принимает аргументов, но возвращает значение, которое берет у пользователя. Тоже относится к функции rd_int(), только она возвращает число, а не строку. В случае, если пользователь введет символы, не относящиеся к числам, то прогамма выдаст ошибку.

Вот полный перечень функций с описанием, который имеется в APLFH. Символом "*" помечены те, которые нуждаются в подключении штатных библиотек (функция для этого и список библиотек - ниже)
null: - Значение, которое обозначает пустоту. используется если что-то отсутствует
false: - Негативное значение чего-то. Используется, как обозначение ложности утверждения. На машинном коде обозначается как 0
true: - Позитивное значение чего-то. Используется, как обозначение правдивости утверждения. На машинном коде обозначается как 1
pi: - Значение числа пи(3.141592....). Используется еслни нужно нарисовать круги и/или окружности.
op(arg): - Команда которая выводит в терминал аргумент
op_ret(arg): Превращает тип переменной аргумента в string
rd(arg): - Позволяет вписать нужные данные в переменную
rd_int(arg): Позволяет вписывать ТОЛЬКО числовые данные
clear(): - Очищает терминал. Если засорился терминал, то это лучшее средство :)
is_num(arg): Проверяет, является ли аргумент - числом (в случае,если это так -  возвращает true, иначе - false).
is_str(arg): Проверяет, является ли аргумент текстом (в случае,если это так -  возвращает true, иначе - false).
is_list(arg): Проверяет, является ли аргумент списком. (в случае,если это так -  возвращает true, иначе - false).
is_f(arg): Проверяет, является ли аргумент функцией. (в случае,если это так -  возвращает true, иначе - false).
append(list, arg): добавляет определённый аргумент в определённый список. 
pop(list, idx): Удаляет элемент из списка с определённым индексом
extend(list1,list2): Позволяет объединить два списка. Добавляет в конец list1 все ячейки list2 по порядку
random(): Позволяет сгенерировать случайное число. Пригодится если нужно указать количество друзей :(










